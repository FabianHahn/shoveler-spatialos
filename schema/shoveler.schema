package shoveler;

type Vector2 {
	float x = 1;
	float y = 2;
}

type Vector3 {
	float x = 1;
	float y = 2;
	float z = 3;
}

/** Layer type of this chunk layer. */
enum ChunkLayerType {
	CANVAS = 0;
	TILEMAP = 1;
}

/** Represents a coordinate mapping from a 3d position onto another single coordinate dimension. */
enum CoordinateMapping {
	POSITIVE_X = 0;
	NEGATIVE_X = 1;
	POSITIVE_Y = 2;
	NEGATIVE_Y = 3;
	POSITIVE_Z = 4;
	NEGATIVE_Z = 5;
}

/** Represents the type of geometry represented by a drawable. */
enum DrawableType {
	CUBE = 0;
	QUAD = 1;
	POINT = 2;
}

/** Represents the type of shader to use for a material. */
enum MaterialType {
	COLOR = 0;
	TEXTURE = 1;
	PARTICLE = 2;
	TILEMAP = 3;
	CANVAS = 4;
	CHUNK = 5;
	TILE_SPRITE = 6;
	TEXT = 7;
}

/** Specifies an OpenGL polygon mode for rendering geometry. */
enum PolygonMode {
	POINT = 0;
	LINE = 1;
	FILL = 2;
}

/** Specifies the type of a light source. */
enum LightType {
	SPOT = 0;
	POINT = 1;
}

/** Defines a perspective camera with a projection and a reference frame. */
type PerspectiveCamera {
	Vector3 direction = 1;
	Vector3 up = 2;
	float field_of_view_y = 3;
	float aspect_ratio = 4;
	float near_clipping_plane = 5;
	float far_clipping_plane = 6;
}

type CreateClientEntityRequest {

}

type CreateClientEntityResponse {

}

type ClientPingRequest {
	EntityId client = 1;
}

type ClientPingResponse {
	int64 server_heartbeat = 1;
}

type ClientSpawnCubeRequest {
	EntityId client = 1;
	Vector3 direction = 2;
	Vector3 rotation = 3;
}

type ClientSpawnCubeResponse {

}

type DigHoleRequest {
	EntityId client = 1;
}

type DigHoleResponse {

}

type UpdateResourceRequest {
	EntityId resource = 1;
	string type_id = 2;
	bytes content = 3;
}

type UpdateResourceResponse {

}

/** Bootstrap component authoritative on the server worker that acts as client-facing server API. */
component Bootstrap {
	id = 1334;
	/** Requests spawning of a client entity for the calling worker. */
	command CreateClientEntityResponse create_client_entity(CreateClientEntityRequest);
	/**
	 * Notifies the server worker that the calling client worker is still alive.
	 *
	 * Every client needs to call this regularly, or the server worker will delete the client's entity.
	 */
	command ClientPingResponse client_ping(ClientPingRequest);
	/** Requests spawning of a cube entity at the calling worker's current position. */
	command ClientSpawnCubeResponse client_spawn_cube(ClientSpawnCubeRequest);
	/** Requests digging a hole at the player's current position. */
	command DigHoleResponse dig_hole(DigHoleRequest);
	/** Requests updating a resource. */
	command UpdateResourceResponse update_resource(UpdateResourceRequest);
}

/** Marks an entity as the player entity of a client playing the game. */
component Client {
	id = 1335;
	EntityId position = 1;
	option<EntityId> model = 2;
}

/** Server-side metadata associated with each connected client. */
component ClientInfo {
	id = 133742;
	string worker_id = 1;
	float color_hue = 2;
	float color_saturation = 3;
}

/** Component for the server worker to keep track of the last heartbeat sent by the client represented by this entity. */
component ClientHeartbeat {
	id = 1336;
	/** Unix timestamp with the last heartbeat the client sent. */
	int64 last_server_heartbeat = 1;
}

/** Represents a resource that is loaded as an asset into the game engine from a binary representation. */
component Resource {
	id = 1337;
	/**
	 * The type ID of the asset.
	 * The only currently supported value is the string "image/png".
	 */
	string type_id = 1;
	/** Bytestring representation of the resource. */
	bytes content = 2;
}

/** Represents a texture that can be used within a material. */
component Texture {
	id = 1338;
	/** Dependency entity ID containing a Resource component with the image for the texture. */
	EntityId image_resource = 1;
}


/** Represents a texture that can be used within a material. */
component Sampler {
	id = 13381;
	/** If true, texture lookups use linear interpolation instead of nearest neighbor. */
	bool interpolate = 1;
	/** If true, auto-generates and mipmaps for the texture. */
	bool use_mipmaps = 2;
	/** If true, texture lookups are clamped on the texture boundaries. */
	bool clamp = 3;
}

/** Represents a tileset that can be added to a tilemap and be referenced by tilemap tiles. */
component Tileset {
	id = 1339;
	/** Dependency entity ID containing a Resource component with the image for the tileset. */
	EntityId image_resource = 1;
	/** Number of tile columns in the tileset, must be in [0, 255]. */
	int32 num_columns = 2;
	/** Number of tile rows in the tileset, must be in [0, 255]. */
	int32 num_rows = 3;
	/**
	 * Number of pixels of padding to insert between tiles to avoid rendering artifacts due to OpenGL texture atlas lookup.
	 * If set to 0, the tileset image will be used unchanged but might display flickering line artifacts between tiles.
	 * If set to 1, line artifacts should disappear.
	 * Higher numbers than 1 are supported but won't have a beneficial effect since mipmaps are currently disabled.
	 */
	int32 padding = 4;
}

/** Represents tiles of a tilemap to be rendered. */
component TilemapTiles {
	id = 1340;
	/**
	 * If set, specifies dependency entity ID containing a Resource component with the image for the tilemap.
	 * The image needs to have three channels (rgb), each pixel of which represents a tile:
	 *  - r channel: Column index of the referenced tile in the tileset.
	 *  - g channel: Row index of the referenced tile in the tileset.
	 *  - b channel: ID of the tileset in the tilemap these tiles are rendered on.
	 *    Tileset IDs start with 1, where 0 denotes a blank tile that isn't rendered on these tiles.
	 */
	option<EntityId> image_resource = 1;
	/** Number of tile columns in the tilemap tiles, must be in [0, 255]. */
	option<uint32> num_columns = 2;
	/** Number of tile rows in the tilemap tiles, must be in [0, 255]. */
	option<uint32> num_rows = 3;
	/** Array of tileset column bytes, where tile (column, row) is at position [row * numColumns + column]. */
	option<bytes> tileset_columns = 4;
	/** Array of tileset row bytes, where tile (column, row) is at position [row * numColumns + column]. */
    option<bytes> tileset_rows = 5;
    /** Array of tileset id bytes, where tile (column, row) is at position [row * numColumns + column]. */
    option<bytes> tileset_ids = 6;
}

/** Represents a tilemap with tiles to render and multiple referenced tilesets to be rendered. */
component TilemapColliders {
	id = 134132;
	/** Number of tile columns in the tilemap colliders, must be in [0, 255]. */
	int32 num_columns = 1;
	/** Number of tile rows in the tilemap colliders, must be in [0, 255]. */
    int32 num_rows = 2;
	/** Array of collider boolean bytes, where tile (column, row) is at position [row * numColumns + column] */
    bytes colliders = 3;
}

/** Represents a tilemap with tiles to render and multiple referenced tilesets to be rendered. */
component Tilemap {
	id = 1341;
	/** Dependency entity IDs containing a TilemapTiles component. */
	EntityId tiles = 1;
	/** Dependency entity IDs containing a TilemapColliders component. */
    EntityId colliders = 2;
	/**
	 * List of dependency entity IDs each containing a Tileset component.
	 * Each tileset is assigned an increasing tileset ID starting with 1.
	 * The initial tileset ID 0 is used to denote tiles that should not be rendered.
	 */
	list<EntityId> tilesets = 3;
}

/** Represents a sprite that is rendered as a single tile from a tileset. */
component TileSprite {
	id = 1342;
	/** Dependency entity ID containing a Position component referenced by this tile sprite. */
    EntityId position = 1;
    /** Dependency entity ID containing a Material component referenced by this tile sprite. */
    EntityId material = 2;
	/** Dependency entity ID containing a Tileset component referenced by this tile sprite. */
	EntityId tileset = 3;
	/** The column index of the referenced tile in the tileset, must be in [0, 255]. */
	int32 tileset_column = 4;
	/** The row index of the referenced tile in the tileset, must be in [0, 255]. */
	int32 tileset_row = 5;
	/** The mapping to use from the entity position to the 2d x coodinate. */
	CoordinateMapping position_mapping_x = 6;
	/** The mapping to use from the entity position to the 2d y coodinate. */
	CoordinateMapping position_mapping_y = 7;
	/** The size of the sprite when rendered onto a canvas. */
	Vector2 size = 8;
}

/**
 * Represents the animation of a tile sprite based on its movement.
 *
 * The animation switches between tiles in the tileset depending on the movement direction.
 * The tileset referenced by the tile sprite needs at least four columns for the movement directions down, up, left, and right.
 * It also needs at least three rows which are used for the neutral frame, as well for two alternating movement frames.
 */
component TileSpriteAnimation {
	id = 1343;
	EntityId position = 1;
	/** Dependency entity ID containing a TileSprite component referenced by this animation. */
	EntityId tile_sprite = 2;
    /** The mapping to use from the entity position to the 2d x coodinate. */
    CoordinateMapping position_mapping_x = 3;
    /** The mapping to use from the entity position to the 2d y coodinate. */
    CoordinateMapping position_mapping_y = 4;
	/** Amount of positional displacement that needs to accumulate between movement frames are alternated. */
	float move_amount_threshold = 5;
}

/** Represents an infinite 2d canvas onto which tile sprites can be drawn. */
component Canvas {
	id = 1344;
	/** List of dependency entity IDs each containing a TileSprite component. */
	list<EntityId> tile_sprites = 1;
}

component ChunkLayer {
    id = 1345;
    ChunkLayerType type = 1;
    option<EntityId> canvas = 2;
    option<EntityId> tilemap = 3;
}

/** Represents a chunk with multiple layers. */
component Chunk {
	id = 13451337;
	/** Dependency entity id of the position to use for the chunk. */
	EntityId position = 1;
	/** The mapping to use from the entity position to the chunk center's 2d x coodinate. */
	CoordinateMapping position_mapping_x = 2;
	/** The mapping to use from the entity position to the chunk center's 2d y coodinate. */
	CoordinateMapping position_mapping_y = 3;
	/**
	 * Denotes the 2d size of this chunk.
	 * For each canvas layer in the chunk, only this chunk's region will be rendered.
	 */
	Vector2 size = 4;
	/**
	 * List of dependency entity IDs each containing a ChunkLayer component to be rendered.
	 * Layers will be rendered in the order they appear in the list, later ones drawing over earlier ones.
	 */
	list<EntityId> layers = 5;
}

/** Represents drawable geometry that can be rendered. */
component Drawable {
	id = 1346;
	DrawableType type = 1;
	option<int32> tiles_width = 2;
	option<int32> tiles_height = 3;
}

/** Represents a material containing a shader that can be used to render geometry. */
component Material {
	id = 1347;
	MaterialType type = 1;
	option<EntityId> texture = 2;
	option<EntityId> texture_sampler = 3;
	option<EntityId> tilemap = 4;
	option<EntityId> canvas = 5;
	option<EntityId> chunk = 6;
	/** If type is set to COLOR, specifies the color of the material. */
	option<Vector3> color = 7;
	/** If type is set to CANVAS, specifies the position of the region to render by the material. */
	option<Vector2> canvas_region_position = 8;
	/** If type is set to CANVAS, specifies the size of the region to render by the material. */
	option<Vector2> canvas_region_size = 9;
}

/**
 * Represents an instance of a drawable with a model transformation and a material that can be rendered in a scene.
 *
 * The model always declares a dependency on the Position component of the same entity, which places it in 3D space.
 */
component Model {
	id = 1348;
	/** Dependency entity ID containing a Position component used by this model. */
	EntityId position = 1;
	/** Dependency entity ID containing a Drawable component referenced by this model which specifies the geometry. */
	EntityId drawable = 2;
	/** Dependency entity ID containing a Material component referenced by this model which specifies the shader. */
	EntityId material = 3;
	/** Rotation of the model in 3D space. */
	Vector3 rotation = 4;
	/** Scale of the model in 3D coordinate axes. */
	Vector3 scale = 5;
	/** If false, scene passes will skip this model. */
	bool visible = 6;
	/**
	 * If true, marks this model as an emitter.
	 *
	 * Emitters are rendered in a special render pass after lights have illuminated the scene.
	 * Their color is rendered additively to the scene.
	 */
	bool emitter = 7;
	/**
	 * If true, marks this model as a shadow caster.
	 *
	 * Shadow casters are rendered into light cameras to determine a light's shadow volume.
	 * Models that aren't shadow casters let light pass through them as if they were transparent (though they might not render their color with transparency).
	 */
	bool casts_shadow = 8;
	/** OpenGL polygon mode to use when rendering the model's geometry. */
	PolygonMode polygon_mode = 9;
}

/**
 * Represents a light that can illuminate models in the scene and cast shadows onto models with applicable materials.
 *
 * The light always declares a dependency on the Position component of the same entity, which places it in 3D space.
 */
component Light {
	id = 1349;
	/** Dependency entity ID with position component to use for the light. */
	EntityId position = 1;
	/** Type of this light source. */
	LightType type = 2;
	/** The width of the framebuffer to use for the light's shadow volume. */
	uint32 width = 3;
	/** The height of the framebuffer to use for the light's shadow volume. */
	uint32 height = 4;
	/** The number of samples per pixel to use when rendering the light's shadow volume. */
	uint32 samples = 5;
	/** Phong ambient factor to use for this light source. */
	float ambient_factor = 6;
	/** Exponential factor to use for exponential shadow mapping of this light source. */
	float exponential_factor = 7;
	/** Color of this light source. */
	Vector3 color = 8;
}

